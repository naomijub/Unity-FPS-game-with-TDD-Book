<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unity FPS game with TDD</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00-capa.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="01-audience.html"><strong aria-hidden="true">2.</strong> Target Audience</a></li><li class="chapter-item expanded "><a href="part-1/02-capa.html"><strong aria-hidden="true">3.</strong> Understanding TDD and other Agile practices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/03-tdd-deepdive.html"><strong aria-hidden="true">3.1.</strong> Deepdive into TDD</a></li><li class="chapter-item expanded "><a href="part-1/04-what-is-tdd.html"><strong aria-hidden="true">3.2.</strong> What is Tdd?</a></li><li class="chapter-item expanded "><a href="part-1/05-when-to-tdd.html"><strong aria-hidden="true">3.3.</strong> When to use TDD?</a></li><li class="chapter-item expanded "><a href="part-1/06-tdd-way.html"><strong aria-hidden="true">3.4.</strong> Learning the TDD Way</a></li><li class="chapter-item expanded "><a href="part-1/07-why-ci.html"><strong aria-hidden="true">3.5.</strong> CI, why does it matter?</a></li><li class="chapter-item expanded "><a href="part-1/08-ci-for-games.html"><strong aria-hidden="true">3.6.</strong> CI for Games</a></li><li class="chapter-item expanded "><a href="part-1/09-engine-game-testing.html"><strong aria-hidden="true">3.7.</strong> Introduction to game testing with game engines and setting up a test environment.</a></li><li class="chapter-item expanded "><a href="part-1/10-best-practices.html"><strong aria-hidden="true">3.8.</strong> Best Practices for Writing Tests</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/11-capa.html"><strong aria-hidden="true">4.</strong> TDDing a FPS Game in Unity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/12-developing-fps-game.html"><strong aria-hidden="true">4.1.</strong> Developing a FPS game with TDD</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Unity FPS game with TDD</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unity-fps-game-with-tdd"><a class="header" href="#unity-fps-game-with-tdd">Unity FPS game with TDD</a></h1>
<p>By Julia Naomi Boeira.</p>
<p>Associated repository: <a href="https://github.com/naomijub/FPSwithTDD">github: naomijub/FPSwithTDD</a></p>
<p><a href="https://naomijub.github.io/FPSwithTDD/">Play the game</a></p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<p><a href="https://github.com/sponsors/naomijub">Github Sponsor</a></p>
<h1 id="target-audience"><a class="header" href="#target-audience">Target Audience</a></h1>
<p>For a long period of time, the gaming industry seemed resistant to agile methodologies, sadly, it seems to come from a few frustrated attempts to introduce agile methodologies in daily routines. I believe that this failed attempts happened because people did not try to adapt the frameworks to their worlds or people tried to introduce &quot;the agile&quot; framework as unique and undivisible thing, which made people see the framework as more than it really is and forgetting from where agile methodologies come from, the <a href="http://agilemanifesto.org/iso/ptbr/manifesto.html">Agile Manifesto</a>.</p>
<ul>
<li><strong>Individuals and interactions</strong> over processes and tools </li>
<li><strong>Working software</strong> over comprehensive documentation </li>
<li><strong>Customer collaboration</strong> over contract negotiation </li>
<li><strong>Responding to change over</strong> following a plan</li>
</ul>
<p>What seems to have been the most common error is the inversion right in the first line of the manifesto, since it seems that the game development world was going &quot;processes and tools over individuals and interactions&quot;. More than that, the industry took processes, tools and frameworks in a quite rigid and inflexible perspective, which is pretty sad, being such a dynamic industry. There was even an article, Agile Game Development is Hard by Rob Galanakis, in 2014, demonstrating the anti-agile mindset. Happily, in the past 5 years I have seen a great amount of change in this context, which makes strategies like TDD for game development something more useful and welcomed in a more friendly manner to the gaming industry.</p>
<p>Besides that, I see TDD (test driven development) as a manifestation of the second principle in the manifesto. I believe this is due to the fact that a well tested code can be seen as documentation, proves the code is working and it has a minimal standard of quality. </p>
<p>Having said that, I believe this book is great for everyone that wishes to improve their coding skills, learn TDD and learn Unity Development. Beginners will have the opportunity the learn step by step how to develop a game with detailed explanations over the language and tooling used, more advanced users will have a nice alternative to learn TDD, indie developer will be able to improve their testing skill, and for big studios this book is an opportunity to improve the general code quality and challenge their developers.</p>
<h1 id="understanding-tdd-and-other-agile-practices"><a class="header" href="#understanding-tdd-and-other-agile-practices">Understanding TDD and other Agile practices</a></h1>
<ul>
<li>Deepdive into TDD</li>
<li>What is TDD</li>
<li>Why use TDD for Games</li>
<li>When to use TDD</li>
<li>Learning the TDD Way</li>
<li>CI, Why does it matter?</li>
<li>CI for Games</li>
<li>Introduction to game testing with game engines and setting up a test environment</li>
<li>Best Practices Writing Tests</li>
<li>Summary</li>
</ul>
<h1 id="chapter-1-deepdive-into-tdd"><a class="header" href="#chapter-1-deepdive-into-tdd">Chapter 1: Deepdive into TDD</a></h1>
<p>To understand TDD, which means test driven development, we need to understand the concepts of <strong>test to code</strong>. Which basically means that we need to have a perspective of what we want before starting developing the game. This has to be done in a way that we know beforehand which tests we are going to write and how we can iterate over them to develop our game. Also, it is important that our tests have a positive impact in our code, as redundant testing doesn't really improve the code quality, therefore, simply writing a test that passes right away doesn't improve our code, even though it can be useful sometimes outside the TDD flow. This means that a meaningful test has to break the current game flow, by failing, and the code that we write from that point on should be the minimum for our test to start passing. More than that, just passing is not enough, it should pass the test that we have written and not break the other tests that we wrote. There is a famous image on TDD that is sometimes called the mantra of TDD &quot;red (test), green (code), refactor' which I would like to explain:</p>
<p><img src="part-1/../Images/tdd-cycle.png" alt="TDD Cyle" />
Image: TDD Cyle</p>
<p>Unfortunately this image may not be very intuitive, so let's explain it a bit.</p>
<ol>
<li>We need to understand our test cases and what we want from them. </li>
<li>We do that by writing the smallest test that fails and aggregates value to our game, considering how we planned for the game to be developed.</li>
<li>Having a failing test is something that we can't accept, so we write the minimal amount of code that makes our failing test pass without failing all of our other tests.</li>
<li>Now we can go further and refactor our code. Refactoring means that we will look for code smells, redundancies and things we can eliminate, so that we can improve the code quality. To do that we need to make sure all our tests keep passing. </li>
<li>Now we can loop back to step 2 until there are no more test cases.</li>
<li>At last, all our test cases are done. We can check if it integrates and it is functional within our code.</li>
<li>Go to step 1 again for other test cases.</li>
</ol>
<h1 id="chapter-2-what-is-tdd"><a class="header" href="#chapter-2-what-is-tdd">Chapter 2: What is TDD?</a></h1>
<p>TDD is a software development practice developed by Kent Beck alongside the eXtreme Programming (XP) methodology. TDD's idea is to develop a system based on its test cases. Therefore, you should elaborate your test cases and then elaborate them into tests in such a way that the planned functionality should evolve from the demands of each test written. As the code solution is implemented right after the test is written, TDD is a continuous cycle of testing and coding.</p>
<p>TDD has a few important characteristics:</p>
<ol>
<li><strong>Frequently execute your tests</strong>. If your tests are being executed frequently it is easy to know the general state of the code. This doesn't mean that you need to run all your test pipeline all the time, but it is useful to run them every time you finish a feature.</li>
<li><strong>Keep your code tested</strong>. It is important to keep your code tested, especially at the unitary level. The smallest code units you test, the easier will be to fix bugs.</li>
<li><strong>Think of a failing test as if it was a failing project build</strong>. If a developed code makes its respective test fail or even another test fails, you should deal with it as if you are putting a bug into the game. Some people just delete the written code and try again from scratch. Finding what works for you is crucial.</li>
<li><strong>Keep your tests simple</strong>. Complex tests may not be testing the units they were supposed to test.</li>
<li><strong>Test cases should be independent from one another</strong>. Each test should only test its unit, component, functionality or how two specific parts work together.</li>
</ol>
<p>Some advantages of TDD can be:</p>
<ul>
<li>Code becomes cleaner, more readable and more maintainable.</li>
<li>A more modular code. Which also increases code testability.</li>
<li>You will have a higher test coverage.</li>
<li>You will possibly find one of the simplest solutions to your problem.</li>
<li>You will have less defects.</li>
<li>You will have less bugs.</li>
<li>You will have extensive documentation of what your code does.</li>
<li>A more eloquent design of the code.</li>
</ul>
<p>As there is no silver bullet, here are some disadvantages of TDD:</p>
<ul>
<li>TDD won't prevent bugs that your test cases introduced or that you have not thought of, this is why things like regression tests can help.</li>
<li>To some people, TDD is a slower process. In my opinion, if you don't do TDD you will be required to work more finding bugs.</li>
<li>All team members got to do it. If only one member includes untested code, that can become a problem to refactor and control in the future. Code reviews help with this item.</li>
<li>When a requirement changes, your tests need to change as well.</li>
</ul>
<h2 id="why-are-there-so-many-poorly-tested-codes"><a class="header" href="#why-are-there-so-many-poorly-tested-codes">Why are there so many poorly tested codes?</a></h2>
<p>Would you use a bullet proof vest that was not tested? If not, you should start seeing test development the same way. Let me tell you a small secret, a bunch of years ago I did not like TDD, unit testing and many other test cases that I, as a software engineer, should be writing. I would mostly test code, global variables and local variables printing data to the terminal, and now, here I am evangelizing in the name of TDD. What happened?</p>
<p>As a game developer, in the past, I wrote many untested lines of code, and the result was that I always had to rewrite part of it, sometimes due to some manual testing and most often due to code so complex that was unreadable. This became one problem less the moment I adopted TDD. Of course, in the beginning I took way longer to write my code, but in general there was no need for rework and I could deliver more value through my code.</p>
<p>Besides that I realized a few reasons why testing was so poorly made in the gaming industry and the software industry as a whole:</p>
<ul>
<li>If tests are not easily comprehensible, bugs can be added to the program generating catastrophical situations.</li>
<li>Tests are usually written after the code, which is a problem because whoever wrote the algorithm doesn't want to go back to coding if from the beginning to find a solution, so the test is usually made to fit the current code.</li>
<li>Tests are usually written by people different from the ones that wrote the code, which can mean that they may have the wrong interpretation of what the code should do or even are just thinking of different requirements. Also, it is harder to test unitary blocks.</li>
<li>If the person that writes the tests writes it based on documentation or artifacts, any upgrades can make the tests become obsolete. </li>
<li>Non automated tests don't run frequently and may not be executed the same way each time. </li>
<li>Fixing a bug in one place may cause a problem elsewhere. Test coverage guarantees some safety over this. </li>
</ul>
<p>And TDD may solve all of these problems as the person that develops the code will test it first, guaranteeing test coverage and testability. It is easier to execute tests in an automated manner. Bugs can be identified quickly and with punctuality, which will be guaranteed by test coverage. And at last, whenever the code is delivered, the tests are delivered alongside it, which improves maintainability. </p>
<h1 id="chapter-4-when-to-use-tdd"><a class="header" href="#chapter-4-when-to-use-tdd">Chapter 4: When to use TDD?</a></h1>
<p>As I said before, TDD is not a silver bullet, but it does have a strange effect on you. Although it is not always necessary, once you get used to it, you will probably do it anywhere. TDD can greatly be applied to the following scenarios:</p>
<p><strong>Browser front-end development</strong>. Whenever someone is developing a web page, it may be very interesting to develop it with TDD as web pages usually have different usage possibilities and you want to make sure that the user will have a great experience using it. Also, it is important to make sure your system is able to handle the data received from the back-end and correctly renders it. Here you can have a whole pyramid of tests with unit tests, integration tests, functional tests, UI tests.</p>
<p><strong>Microservices and back-end</strong>. They run the web, but now imagine your bank doesn't test how your money will be handled and saved. This means that any bug can cause you to lose a great amount of money. Backends are the origin of TDD usage and they are critical for games as well. Most common tests for backends are unit tests, integration tests, contract tests and some end-to-end testing.</p>
<p><strong>Mobile apps</strong>. This is very similar to front-end requirements, as mobile apps can cause your user to have a terrible experience, but more than that, they are constantly updated, so having a good CI is important for them. </p>
<p><strong>Games</strong>. Well, if we test UIs for mobile and for browsers, why can't we test UIs for games? There is the random state factor, but this can easily be solved by pure functions which would allow our logic functions not to have side effects and they will generate a precise response and a precise UI. With precise states for UIs we can define how we want our game UI to look like. Also we can test the connection to our servers and how they affect the general game state. Again, you can have a whole pyramid of tests with unit tests, integration tests, functional tests, UI tests.</p>
<p><strong>IoT and Embedded</strong>. Just imagine the chaos it would be if your television had a bug that turned on your microwave, which you left something inside, when you are not expecting it to happen. Or just imagine a critical bug failure in the airplane you're flying. Testing these for unit level and integration level seems quite important.</p>
<p>But I said that it couldn't be applied to all scenarios, right?</p>
<p><strong>Famous and known algorithms</strong>. You can use TDD to solve a merge sort algorithm, but you probably won't get to a better solution than the classical algorithm. So, although testing can give you confidence that you wrote the correct solution/algorithm, TDD won't actually help you to find the best solution every time. Though it does help to have a cleaner code. </p>
<p><strong>Research and Development projects</strong>. These kinds of projects usually are just spikes or proof of concepts, and they are made just to prove a point or show a new technology.  Although testing them could be beneficial, for later usage, it can be time consuming.</p>
<p>There are more cases for both sides, but I see this as the most important scenario to discuss TDD.</p>
<h1 id="chapter-5-learning-the-tdd-way"><a class="header" href="#chapter-5-learning-the-tdd-way">Chapter 5: Learning the TDD Way</a></h1>
<p>Now we can start speaking about TDD for games, so in this chapter we will learn about test pyramid and test levels, how to think of test cases and what would be a minimum viable game from a testing perspective.</p>
<p>First of all I would like to start with one definition of test levels that I find the most interesting. However there are many more and many that are different from mine, you and your team should reach a consensus over this topic before starting.</p>
<ul>
<li><strong>Unit testing</strong>. They should be testing a fundamental part of the game like a logic, a function, a routine and some controlled behavior inside a namespace or a class. They are the most common type of tests in TDD books and they usually use some variant of the word ASSERT to define the logical boundaries of the test.</li>
<li><strong>Functional testing</strong>. They test if a function or an object reacts to some behaviour in an expected manner from a black box perspective. So they usually do this by using some input and observing the output.</li>
<li><strong>UI testing</strong>. Sometimes they are put together with the functional testing, but they represent a test that takes a screenshot and compares it with an expected image.</li>
<li><strong>Component testing</strong>. They test if the execution of a game object, a package, a subroutine or an internal program are working as expected. A good example would be to test the reactions of a NPC when reacting to the player.</li>
<li><strong>Integration testing</strong>. This can be a little confusing in the game industry as many people call component tests integration tests as well, sometimes even functional tests. But in general it tests the communication of our game with external resources, like servers, kinect, controller and audio. Testing player input can be a great example. </li>
<li><strong>End-to-end testing</strong>. I would say this is the simplest test for games, it would be an automated gameplay test.</li>
</ul>
<p>One very important aspect of TDD is the test pyramid, as it represents loosely how much of each test your project should have. In a general sense the more unitary and low level your test is, the more of this kind you need to have, while tests that take longer or are more high level should have less amount. This is due to the fact that unit tests are way cheaper than integration tests, which are cheaper than end to end and UI tests. So the pyramid base should contain a lot of Unit tests, followed by a bunch of integration tests, a few functional and UI tests and very little end-to-end tests. Projects can separate tests by functionality, classes and context or by pyramid level. Which one to choose depends on what you and your team prefer and both of them are valid. </p>
<h2 id="imagining-simple-test-cases-for-a-game"><a class="header" href="#imagining-simple-test-cases-for-a-game">Imagining simple test cases for a game</a></h2>
<p>Talking about a minimum viable game I was inspired to find out which would be the test cases for a movement mechanic in a platform 2D game and what a player would expect from it. For example, in the last project I participated in, a few colleagues of mine were having trouble understanding that we should first define and validate the mechanics that we want so that we could start fine tuning them. The result was that they didn't listen to me, were only preoccupied with the fine tuning of the first mechanic, which resulted in the fact that they almost blew the deadline and the result was terrible because we had one good mechanic and a lot of terrible mechanics.</p>
<p>Considering the basic move mechanics of a platform 2D game, like Mario, we would have walk, jump and fall mechanics. So how could we test them?</p>
<h3 id="walk-mechanic"><a class="header" href="#walk-mechanic">Walk Mechanic</a></h3>
<p>| Feature  	| Character must move alongside the X axis   	|
|---	|---	|
| Input   	| Keyboard input   	|
| Test Case 1  	| Any key is pressed on the keyboard.  	|
| Test Case 2  	| Directional keys were pressed on the keyboard (left/right or a/d)  	|
| Test Case 3   	| When the left key is pressed the character moves left   	|
| Test Case 4   	| When the right key is pressed the character moves right   	|
| Test Case 5   	| When any other key is pressed, nothing happens in the X axis.   	|
| Test Case 6   	| Character collides with walls   	|
| Output   	| If the new position is as expected, the test passes, else it fails.   	|</p>
<h3 id="jump-mechanic"><a class="header" href="#jump-mechanic">Jump Mechanic</a></h3>
<p>| Feature  	| Character must jump   	|
|---	|---	|
| Input   	| Keyboard input   	|
| Test Case 1  	| Spacebar was pressed  	|
| Test Case 2  	| When spacebar is pressed character moves alongside the Y axis  	|
| Test Case 3   	| The character moves correctly from bottom-up. More than one assert may be needed for this test.   	|
| Test Case 4   	| The character moves correctly, when falling from the jump, from top-bottom. More than one assert may be needed for this test.   	|
| Test Case 5   	| When a directional key is pressed, the jump occurs alongside the X axis as well.   	|
| Test Case 6   	| Verifies if a jump with directional keys pressed is parabolic.    	|
| Output   	| If the new position is as expected, the test passes, else it fails.   	|</p>
<ul>
<li>Usually a complete jump requires at least 5 assertions to check for correct movement.</li>
</ul>
<h3 id="fall-mechanic"><a class="header" href="#fall-mechanic">Fall mechanic</a></h3>
<p>| Feature  	| Character must fall into holes   	|
|---	|---	|
| Input   	| Character collides with scene   	|
| Test Case 1  	| Character collides with floor  	|
| Test Case 2  	| Character collides with aerial blocks  	|
| Test Case 3   	| Character falls into holes (gravity testing)   	|
| Test Case 4   	| Character falls into holes following a horizontal launch.   	|
| Test Case 5   	| Same as 4 but from aerial blocks   	|
| Output   	| If the new position is as expected, the test passes, else it fails.   	|</p>
<p>Engineers may find very different ways to solve these test cases. However, the most important part is to keep the test cases simple and the test resolutions and assertion even simpler. If any step gets hard or confused, a good strategy is to take a step back to the intermediary test cases and try to grow the concept from them. This also helps to refactor and evolve the code. </p>
<p>So now, we can consider that you already know the basic principles of TDD and we can start developing our own game.</p>
<h1 id="chapter-6-ci-why-does-it-matter"><a class="header" href="#chapter-6-ci-why-does-it-matter">Chapter 6: CI, why does it matter?</a></h1>
<p>First of all, CI means Continuous Integration and it is a development practice where developers integrate code into a shared repository frequently. Each time someone integrates with the integration engine, automated builds, automated formatting, automated linting and/or automated tests may be executed. Another step that is sometimes used is Pull Request reviews and some continuous delivery practices. </p>
<h2 id="why-should-we-be-concerned-about-ci"><a class="header" href="#why-should-we-be-concerned-about-ci">Why should we be concerned about CI?</a></h2>
<p>CI strategies don't really reduce bugs, but they definitely help detecting them quicker, as the code is frequently integrated so that build systems and test runners are always running. Whenever they fail, a bug might be present and some action needs to be taken. Having said that, we can point out a few benefits of CI strategies:</p>
<ul>
<li>Bug detection - besides the fact that tests and builds should be executed whenever the code is integrated and if anything fails it is quickly fixed before merging, detecting when other bugs occured or were introduced is way faster, so the mean time to resolution should be reduced.</li>
<li>Version control - usually CIs are integrated with version control systems, which help us identify merge clonflicts and have a clear idea of the current code state.</li>
<li>More test reliability - test reliability is increased as every test scenario is executed when weh commit any changes, making sure that each scenario that has a test is correctly tested for the current changes. </li>
<li>Faster release rate - as the code state is always being checked, the main branch is always ready to be deployed and used.</li>
<li>Reduces critical defects - as less bugs go into production, there are less critical defects to be dealt with after commiting, which in a general sense also reduces backlog, as they are probably not going to be introduced. Less bugs also mean less development cost.</li>
<li>Easy Maintenance and Updates - as the code state is nearly guaranteed to be correct in the main branch, fixes and updates are easier to implement.</li>
<li>Documentation - many CIs have a documentation generation and release from the code integrated into the main branch. </li>
</ul>
<p>Only knowing the benefits doesn't make a CI happen, so we need to understand some of the basic practices associated with CI:</p>
<ul>
<li>Have all the code associated with a project or product in the same repository or in some integrated way. For example, monorepos for a product, each section of a product or a project in its own repository or core project in one repository and its libraries in another.</li>
<li>Automated builds, whenever the code is integrated, execute your build system to check if everything is OK.</li>
<li>Execute tests for every build - building can detect some specific or compilation errors, while testing can detect logic or functionality errors. </li>
<li>Keep it quick - avoid long CIs as they make it more dificult to frequently integrate.</li>
<li>Test the code in an environment similar to production - in microservices we usually use container-like strategies to develop and deploy in the same environment. </li>
<li>Anyone can easily have access to the last stable build.</li>
<li>Automated deploy - it is easy to release a test version or a beta version of the product whenever new features are included.</li>
</ul>
<p>Besides knowing the basic practices it is important to know the methodology behind it. This is not the only methodology available, but it is one I find most versatile:</p>
<ol>
<li>Engineers clone the repository into their workspaces.</li>
<li>When all changes are done,  commit them to the remote repository.</li>
<li>For committing into the main branch there are two most common practices. Feature branch, when all the code is committed into a new branch, a pull request is required and code review is done. Or, trunk based development, when all the team is in sync and agrees to some basic development practices and the commits are made directly into the main branches.</li>
<li>The CI server monitors when changes are made in the repository and checks for formatting and linting.</li>
<li>The CI server builds the game and executes its test runner.</li>
<li>The CI server communicates if the build was successful</li>
<li>In case of failure, the CI server communicates to the team. </li>
<li>The team fixes the issues (build, testing, formatting or linting).</li>
<li>The CI server delivers builds for beta testing or testing in the staging environment. </li>
<li>Restart the process for another feature or update. </li>
</ol>
<h2 id="team-responsibilities"><a class="header" href="#team-responsibilities">Team Responsibilities</a></h2>
<p>For TDD and CI to work well there are a few possible team responsibilities that should be observed. Many teams develop their own rituals over these practices and responsibilities, by removing, changing and evolving them, which results in a self managed team, avoiding hierarchical and bureaucratic policies. A few of them are:</p>
<ul>
<li>Keep your code fork up to date.</li>
<li>Check your code and the remote main branch frequently.</li>
<li>Don't commit something that is broken in your machine.</li>
<li>Don't commit untested changes.</li>
<li>Don't add code to a build that is broken, unless it is to fix it.</li>
<li>Don't abandon your code after the commit, wait for the CI to finish.</li>
<li>Honestly review pull requests codes, also known as code review.</li>
</ul>
<h3 id="code-review"><a class="header" href="#code-review">Code Review</a></h3>
<p>Code review is a common agile practice that aims to share knowledge of what is being built as well as receiving feedback on the code that was written and improvements requirements. Besides that, it is usually associated with feature branch practice which enables the CI to be executed more frequently and no code is merged if things break.</p>
<h1 id="chapter-7-ci-for-games"><a class="header" href="#chapter-7-ci-for-games">Chapter 7: CI for Games</a></h1>
<p>There are a large number of CI tools that are compatible with games. However, there might be some resistance to adopt them, so here are a few benefits not only related to the development cycle that can help to sell the CI usage:</p>
<ul>
<li>Non-developers can check the current state of the game at any time, considering that the CI triggers a continuous delivery process for alfa or beta versions.</li>
<li>A press/media version can always be available, for example in a complete example scene.</li>
<li>The publisher can always identify and keep up with the game's current version. </li>
<li>It is guaranteed that the game works on different platforms that have been tested.</li>
<li>It is easy to get the latest build version.</li>
<li>Easier to identify bugs, which is really important to the business side as it can reduce the time to fix them as well as avoid releasing games with bugs.</li>
</ul>
<h2 id="ci-for-unity"><a class="header" href="#ci-for-unity">CI for Unity</a></h2>
<p>As I am of the opinion that every modern software project should have a CI/CD pipeline associated with it, Unity is no exception. There are a few options to configure a CI for Unity, but the most obvious one is <a href="https://docs.unity3d.com/Manual/UnityCloudBuild.html">Unity Cloud Build</a> as it is Unity's native CI tool, it is very well documented and a complete up to date guide can be found in Learn Unity's <a href="https://learn.unity.com/tutorial/unity-cloud-build#5c80546dedbc2a183757dd84">website</a>. However, it may not be the perfect tool for your project and it works better as a continuous builder only tool than a CI/CD tool. The other obvious choice is to use some kind of CI like Github Actions, GitlabCI, Travis-CI, Game.CI or CircleCI. Unfortunately, I have had a lot of problems configuring Unity's CI with Travis-CI and I do not recommend it, as even though it did work at some point, it has to be continuously fixed for future changes. So, as most of my projects are on Github I usually choose Github Actions as my CI. </p>
<p>The best way to create an Unity Github Actions is with the newly created Game.CI, which is a rebrand of Unity Actions, combined with Unity Builder for the build step. </p>
<h2 id="dockerizing-unity"><a class="header" href="#dockerizing-unity">Dockerizing Unity</a></h2>
<p>Game-ci/docker are specialised Unity Docker images for CI and command-line tools, which are named unity-ci/editor and can be found at https://hub.docker.com/r/unityci/editor, choose your unity version. The only problem with this, so far, is the limited IL2CPP support (Ubuntu Only) and versions newer than 2019. You can find your Unity version in Unity Hub as the following image shows:</p>
<p><img src="part-1/../Images/unityverion.png" alt="Project's Unity version in Unity Hub" />
Image: Project's Unity version in Unity Hub</p>
<p>To execute this docker image you can run <code>docker run -it unityci/editor:ubuntu-2020.3.16f1-mac-mono-0 command</code>, which means we want to run a docker container (unityci/editor), in interactive mode (<code>-it</code>) with the tag <code>ubuntu-2020.3.16f1-mac-mono-0</code>. The Unity editor will be located at <code>/opt/unity/Editor</code> as <code>Unity</code>. Now we need to create the activation file, to do that change your directory o the Editors directory by executing <code>cd /opt/unity/Editor</code> and run the command <code>./Unity -quit -batchmode -nographics -lgFile -createManualActivationFile</code>, you will see a message saying <strong>Manual activation license file saved</strong>. The <code>-quit</code> flag tell Unity it need to quit after executing our commands, the <code>-batchmode</code> means it is only going to run on command-line, <code>-nographics</code> means no graphic device is going to be initialized, <code>-logFile</code> outputs the log to the console and <code>-createManualActivationFile</code> will generate a file that allows us to create a license for the docker. You can see the file executing ls and it will be named <code>Unity_v2020.3.16f1.alf</code>. To get the alf file content we can just execute <code>cat Unity_v2020.3.16f1.alf</code> and copy its content (from &lt;?xml…&gt; to </root>):</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;&lt;SystemInfo&gt;&lt;IsoCode&gt;C.UTF&lt;/IsoCode&gt;&lt;UserName&gt;(unset)&lt;/UserName&gt;&lt;OperatingSystem&gt;Linux 5.10 Ubuntu 18.04 64bit&lt;/OperatingSystem&gt;__&lt;UnityVersion Value=&quot;2020.3.16f1&quot; /&gt;&lt;/License&gt;&lt;/root&gt;
</code></pre>
<p>Save this file in your machine as the alf file and go to <a href="https://docs.unity3d.com/Manual/ManualActivationGuide.html">Unity's activation page</a> to get our license file https://license.unity3d.com/manual. Download the <code>Unity*.ulf</code> license file, send the file to your docker container by executing <code>docker cp ./Unity_v2020.x.ulf 1c25b08a74dd:/opt/unity/Editor</code>, which means copy a file from file location in host to container_id 1c25… at path <code>/opt/unity/Editor</code>, container id can be found with <code>docker ps</code>, and activate it by executing <code>./Unity -batchmode -manualLicenseFile Unity_v2020.x.ulf -logfile</code>. Now you can run any game commands with /Unity as long as your container has an associated Dockerfile to build the container with the necessary project files. The game commands that we will run inside the container are equal to the one we will execute, nextly, in github actions.</p>
<h2 id="configuring-github"><a class="header" href="#configuring-github">Configuring Github</a></h2>
<p>There are not a lot of secrets to work with Git and Unity, one important thing is to make sure that you have an up to date <code>.gitignore</code> file and forcing your <code>.meta</code> files to be text mode. To generate and up to date <code>.gitignore</code>, I recommend checking https://www.toptal.com/developers/gitignore/api/unity, just take care when ignoring <code>[Oo]bj</code> and <code>[Bb]uild</code> because some objects and folders use those names and can be ignored. Basic steps are as follows:</p>
<ol>
<li>Create a repo on github.</li>
<li><code>git init</code> you local Unity folder or git clone from remote and start your unity project there. If <code>git init</code> set your remote to the empty repository <code>git remote add origin git@git.path.git</code>.</li>
<li>Add a <code>.gitignore</code> and a License file if required.</li>
<li><code>git add .</code> and commit with <code>git commit -m &quot;&lt;your message&gt;&quot;</code>. Then push.</li>
<li>To create a new work branch you can execute <code>git checkout -b &lt;branch name&gt;</code>.
Another important issue in game development is file locking, Which means that only one person can edit a file at a time. This is because git cannot resolve merge conflicts for blob files with its standard tools. Sound effects, 3D objects, sprite sheets, fonts, tiles and binaries in general need locking, also, prefabs and even meta files can cause huge merging conflicts if not locked. The first recommendation would be to have your locked files concentrated in one or a few folders that don't have code or not frequently edited code.</li>
</ol>
<p>Two important concepts that we can explore for this kind of behavior are partial clones and sparse checkouts. Partial clones allow us to avoid downloading large binary folders so that we can clone them whenever we need them in a just in time manner, discarding the binary objects history. This will help us work only with the latest binaries. A partial clone that removes binaries (blobs) is defined as a clone with a filter tag defining blobs to <code>none</code>, <code>git clone --filter=blobs:none</code>, which will download the blobs metadata but not the file content itself. The sparse flag, <code>--sparse</code> can be used to clone only the files in the root directory and can be used to avoid downloading the blob folders in less complex projects. The whole command can look like <code>git clone --filter=blob:none --sparse git@git.path.git</code>. To retrieve the missing folders without caring about their history you can use the sparse checkout command with the path to the folder/file, <code>git sparse-checkout add /path/to/folder/or/file</code>.</p>
<p>With these techniques we can discuss file locking. File locking works as follows, it is assumed that nobody can write to that file unless explicitly asked and if the file is unlocked. We can do this by using <code>git-lfs</code> file locking feature, which doesn't mean we need to store the files in git-lfs, but we just use its locking feature. To use <code>git-lfs</code> be sure you have lfs installed in your machine and CI and then install it in your project with <code>git lfs install</code>.</p>
<p>To use <code>git-lfs</code> locking feature we need to use a file called <code>.gitattributes</code>, which is a collection of file patterns and attributes, something like <code>**/*.png lockable</code>, that sets the attribute lockable to a PNG files in path <code>**/*</code>. To lock a file for local development you can type <code>git lfs lock /path/to/file</code>, you should receive a message saying <code>Locked /path/to/file</code>. This will lock the file in all branches. To unlock it add the changes, commit them and push, then run <code>git lfs unlock /path/to/file</code>, a message saying <code>Unlocked /path/to/lock</code>.</p>
<h3 id="configuring-github-actions"><a class="header" href="#configuring-github-actions">Configuring Github Actions</a></h3>
<p>We have already generated a license, but now we need to generate a github/workflow that activates this license. First step is to go to your repository in github and click <code>Actions</code>, as Unity doesn't have a preset workflow you will need to click on <code>set up a workflow yourself</code>, which will automatically be called <code>main.yml</code>:</p>
<pre><code class="language-yaml">name: CI
 
on:
 push:
   branches: [ main ]
 pull_request:
   branches: [ main ]
 workflow_dispatch:
 
jobs:
 build:
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@v2
     - name: Run a one-line script
       run: echo Hello, world!
     - name: Run a multi-line script
       run: |
         echo Add other actions to build,
         echo test, and deploy your project.
</code></pre>
<p>Now we can create another yml file named <code>activation.yml</code>, at <code>.github/workflows</code>, that will be responsible for getting Unity's license file:</p>
<pre><code class="language-yaml">name: Gets Unity license activation file
 
on: workflow_dispatch
 
jobs:
 getManualActivationFile:
   name: Gets manual activation file
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@v2
     - uses: game-ci/unity-request-activation-file@v2
       id: getManualLicenseFile
     - uses: actions/upload-artifact@v2
       with:
         name: Manual Activation File
         path: ${{ steps.getManualLicenseFile.outputs.filePath }}
</code></pre>
<p>The name tag is just the name of the action to be executed and <code>on: workflow_dispatch</code> means that this will only be executed when we order it to dispatch. There will be one job named <code>getManualActivationFile</code> running on an Ubuntu machine. This workflow needs to be manually triggered and it will generate a <code>Manual Activation File</code>, to do this go to <code>Actions &gt; Get Unity license activation file &gt; run workflow</code>. Once it is done, the file will be available to download at the workflow execution under the name <code>Manual Activation File</code>. Download the file and unzip it to retrieve the .alf file and follow the same process as we did with docker to retrieve the <code>.ulf</code> file. Now go to your repository Settings then Secrets, copy the ulf file content and paste it into a new repository secret called <code>UNITY_LICENSE</code>.</p>
<p><img src="part-1/../Images/activation.png" alt="Run activation workflow" />
Image: Run activation workflow</p>
<p><img src="part-1/../Images/activation-file.png" alt="Download Manual Activation File" />
Image: Download Manual Activation File</p>
<p><img src="part-1/../Images/unity-license.png" alt="Paste ulf file content into secret UNITY_LICENSE" />
Image: Paste ulf file content into secret UNITY_LICENSE</p>
<p>For professional and pro licenses you will be required to have 3 more repository secrets:</p>
<ul>
<li>UNITY_SERIAL: the professional License serial key.</li>
<li>UNITY_EMAIL: your Unity login email.</li>
<li>UNITY_PASSWORD: your Unity login password.</li>
</ul>
<h2 id="build-your-project-on-the-ci"><a class="header" href="#build-your-project-on-the-ci">Build your project on the CI</a></h2>
<p>Now that we have our project CI configured we can start building it. It makes no sense to build our project in the CI without having a base project, so I recommend you to have an empty project with this step. Let's start simple and then expand our build.</p>
<p>The minimal build for the CI is under Jobs add this <code>simple_build</code>:</p>
<pre><code class="language-yaml">jobs:
 simple_build:
   runs-on: ubuntu-latest
 
   steps:
     - uses: actions/checkout@v2
     - uses: game-ci/unity-builder@v2
       env:
         UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
       with:
         targetPlatform: WebGL
</code></pre>
<p>This build will basically use your <code>UNITY_LICENSE</code> secret, which is accessed using <code>${{ variable }}</code> syntax,  to build your project targeting the WebGL platform. It maybe be useful to store the built artifact, for that you can add a new step after the <code>unity-builder@v2</code> with the following configuration:</p>
<pre><code class="language-yaml">- uses: actions/upload-artifact@v2
  with:
    name: &lt;Your build name&gt;
    path: build
</code></pre>
<p>But this build takes a while to execute and there is a simple way to solve this, which is caching the <code>Library</code> folder. If you check the build description, you will see it took a while to execute all the commands associated with the Library folder, so to cache it we can add:</p>
<pre><code class="language-yaml">- uses: actions/checkout@v2
- uses: actions/cache@v2
  with:
    path: Library
    key: Library-${{ matrix.targetPlatform }}
    restore-keys: Library-
- uses: game-ci/unity-builder@v2
</code></pre>
<p>Note that the cache step is before the <code>unity-builder@v2</code> step and I have added a <code>matrix.targetPlatform</code> variable, which we will shortly use. If you have only one target platform, please use only its name.</p>
<p>To include multiple platforms, we will be required to define a <code>strategy</code> before defining the <code>steps</code>. We can do that by defining the strategy tag that contains a matrix tag with all platforms. Also, we can generate a different build for every platform by naming our build <code>name: Build - ${{ matrix.targetPlatform }}</code>.</p>
<pre><code class="language-yaml">build:
  name: Build - ${{ matrix.targetPlatform }}
  runs-on: ubuntu-latest
  strategy:
    fail-fast: false
    matrix:
      targetPlatform:
        - StandaloneOSX
        - StandaloneWindows
        - StandaloneWindows64
        - StandaloneLinux64
        - iOS
        - Android
        - WebGL
  steps: ...
</code></pre>
<p>There are many other build configurations that can be found in the <a href="https://game.ci/docs/github/builder">GameCI/github/builder page</a>, but for now we are going to start testing our game.</p>
<h2 id="testing-your-project-on-the-ci"><a class="header" href="#testing-your-project-on-the-ci">Testing your project on the CI</a></h2>
<p>Just like unity-builder on CI, unity-test-runner expects some tests to exist, and to do that you should create some Unity tests, which are explained in the next chapter. Test runner is not that easy to start small and expand, because there are many nice configurations we can do to make sure we have a minimal adequate test setup. So, our test job looks like the following:</p>
<pre><code class="language-yaml">jobs:
 testAllModes:
   name: Test in ${{ matrix.testMode }}
   runs-on: ubuntu-latest
   strategy:
     fail-fast: false
     matrix:
       testMode:
         - playmode
         - editmode
   steps:
     - uses: actions/checkout@v2
       with:
         lfs: true
     - uses: actions/cache@v2
       with:
         path: Library
         key: Library-${{ matrix.testMode }}
         restore-keys: |
           Library-
     - uses: game-ci/unity-test-runner@v2
       id: tests
       env:
         UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
       with:
         testMode: ${{ matrix.testMode }}
         artifactsPath: ${{ matrix.testMode }}-artifacts
         githubToken: ${{ secrets.GITHUB_TOKEN }}
         checkName: ${{ matrix.testMode }} Test Results
     - uses: actions/upload-artifact@v2
       if: always()
       with:
         name: Test results for ${{ matrix.testMode }}
         path: ${{ steps.tests.outputs.artifactsPath }}
 build: ...
</code></pre>
<p>Our job will be defined as testAllModes with a name tag that varies depending on the <code>matrix.testMode</code>. <code>Unity-test-runner</code> has three possible modes: <strong>playmode</strong>, which will only execute playmode test, <strong>editmode</strong>, which will only execute editmode tests, and all, which will execute playmode and editmode tests. As a quick reference, editmode tests are unit level tests that don't execute Start, Awake and Update functions from Unity's MonoBehaviour, while playmode tests execute those functions allowing you some control over how many update frames you want. The testModes are defined in <code>strategy &gt; matrix &gt; testMode</code>.  We have already talked about caching, but we don't actually need the testMode variable for this test. Then we execute the <code>unity-test-runner@v2</code> with <code>UNITY_LICENSE</code>, the with tag defines parameters to be used, in which testMode is one of the possible test modes, <code>artifactsPath</code> is where we want to upload our test artifacts, <code>checkName</code> is the name in which we want this artifacts to be and <code>githubToken</code>, which is automatically generated, allows us to the github status check results for our test. Lastly, we upload the artifacts with <code>actions/upload-artifact@v2</code> step, defining that it will always be uploaded, <code>if: always()</code>, under the name <code>Test results for $testMode</code> in the path defined in <code>artifactsPath</code>.</p>
<h3 id="improving-execution-time"><a class="header" href="#improving-execution-time">Improving execution time</a></h3>
<p>One thing that is annoying with this CI configuration is that some git large files take too long to execute. Fortunately there is a solution for this, which is to cache the Git Large File by adding this script after the checkout action, <code>actions/checkout@v2</code>:</p>
<pre><code class="language-yaml">- name: Create LFS file list
  run: git lfs ls-files -l | cut -d' ' -f1 | sort &gt; .lfs-assets-id
- name: Restore LFS cache
  uses: actions/cache@v2
  id: lfs-cache
  with:
    path: .git/lfs
    key: ${{ runner.os }}-lfs-${{ hashFiles('.lfs-assets-id') }}
- name: Git LFS Pull
  run: |
    git lfs pull
    git add .
    git reset --hard
</code></pre>
<p>And the complete script is:</p>
<pre><code class="language-yaml">name: CI
 
on:
 push:
   branches: [ main ]
 pull_request:
   branches: [ main ]
 
 workflow_dispatch:
 
jobs:
 testAllModes:
   name: Test in ${{ matrix.testMode }}
   runs-on: ubuntu-latest
   strategy:
     fail-fast: false
     matrix:
       testMode:
         - playmode
         - editmode
   steps:
     - name: Checkout code
       uses: actions/checkout@v2
       with:
         lfs: true
     - name: Create LFS file list
       run: git lfs ls-files -l | cut -d' ' -f1 | sort &gt; .lfs-assets-id
     - name: Restore LFS cache
       uses: actions/cache@v2
       id: lfs-cache
       with:
         path: .git/lfs
         key: ${{ runner.os }}-lfs-${{ hashFiles('.lfs-assets-id') }}
     - name: Git LFS Pull
       run: |
         git lfs pull
         git add .
         git reset --hard
     - name: Cache Library
       uses: actions/cache@v2
       with:
         path: Library
         key: Library-Test
         restore-keys: |
           Library-
     - name: Run test ${{ matrix.testMode }}
       uses: game-ci/unity-test-runner@v2
       id: tests
       env:
         UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
       with:
         testMode: ${{ matrix.testMode }}
         artifactsPath: ${{ matrix.testMode }}-artifacts
         githubToken: ${{ secrets.GITHUB_TOKEN }}
         checkName: ${{ matrix.testMode }} Test Results
     - name: Upload artifact for test in ${{ matrix.testMode }}
       uses: actions/upload-artifact@v2
       if: always()
       with:
         name: Test results for ${{ matrix.testMode }}
         path: ${{ steps.tests.outputs.artifactsPath }}
 build:
   name: Build - ${{ matrix.targetPlatform }}
   runs-on: ubuntu-latest
   strategy:
     fail-fast: false
     matrix:
       targetPlatform:
         - StandaloneOSX
         - WebGL
 
   steps:
     - name: Checkout code
       uses: actions/checkout@v2
     - name: Create LFS file list
       run: git lfs ls-files -l | cut -d' ' -f1 | sort &gt; .lfs-assets-id
     - name: Restore LFS cache
       uses: actions/cache@v2
       id: lfs-cache
       with:
         path: .git/lfs
         key: ${{ runner.os }}-lfs-${{ hashFiles('.lfs-assets-id') }}
     - name: Git LFS Pull
       run: |
         git lfs pull
         git add .
         git reset --hard
     - name: Cache Library
       uses: actions/cache@v2
       with:
         path: Library
         key: Library-${{ matrix.targetPlatform }}
         restore-keys: Library-
     - name: Build for ${{ matrix.targetPlatform }}
       uses: game-ci/unity-builder@v2
       env:
         UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
       with:
         targetPlatform: ${{ matrix.targetPlatform }}
</code></pre>
<p>Note that I have added names for each step.</p>
<h2 id="deploying-artifacts"><a class="header" href="#deploying-artifacts">Deploying artifacts</a></h2>
<p>Deploying artifacts with a CI is not a big mystery, and it is less of a mystery when we can combine Unity, Wasm, WebGL, Github Actions and Github Pages. In this example we will deploy an artifact to github pages, but the mechanics of doing so is similar in any platform:</p>
<ul>
<li>
<ol>
<li>Generate a build to the target platform in your CI.</li>
</ol>
</li>
<li>
<ol start="2">
<li>Store that build somewhere.</li>
</ol>
</li>
<li>
<ol start="3">
<li>Have the platform deployment credentials stored in your CI.</li>
</ol>
</li>
<li>
<ol start="4">
<li>Run a script that can deploy the build with the correct credentials in the target platform.</li>
</ol>
</li>
</ul>
<p>For  the github actions to deploy to github pages we need to build Unity targeting WebGL, which we already do in our <code>build &gt; strategy &gt; matrix &gt; targetPlatform &gt; WebGL</code> script. However, we still need to store the built artifact somewhere, which we can do by adding the following to the build script:</p>
<pre><code class="language-yaml">      - name: Build for ${{ matrix.targetPlatform }}
        …
      - uses: actions/upload-artifact@v2
        with:
          name: build-${{ matrix.targetPlatform }}
          path: build/${{ matrix.targetPlatform }}
</code></pre>
<p>Basically this means that after we build the artifact for <code>matrix.targetPlatform</code> we will use the action <code>actions/upload-artifact@v2</code> to upload the artifact with name <code>build-${{ matrix.targetPlatform }}</code> in the path <code>build/${{ matrix.targetPlatform }}</code>. Now we need to configure github pages.</p>
<h3 id="configuring-github-pages"><a class="header" href="#configuring-github-pages">Configuring Github Pages</a></h3>
<p>The first thing I do to use github pages is to create a github pages branch, which I usually call <code>gh-pages</code>. Having that branch created we can enable github pages in our repository by going to <code>Settings &gt; Pages</code>. For our purposes now, the only important fields are <strong>sources</strong> and the checkbox <strong>Enforce HTTPS</strong>. </p>
<p>Enforce HTTPS is as it says, it enforces that your page is using HTTPS, while sources is where the configuration actually happens. You can see that your sources have a <code>branch</code> dropdown, choose the branch that you built items will be available, in our case <code>gh-pages</code>, than choose the folder that your build will be, usually there are only two options <code>/root</code> and <code>/docs</code>, I usually deploy to root. Hit the <code>save</code> button. Custom domain is in case you have a hosted domain that you want the code to be deployed to and theme is the theme style that you want your github pages to have.
For Github Pages WebGL projects on Unity make sure to set publishing <code>compression format</code> to <code>disabled</code>. To do this go to <code>File &gt; Build Settings &gt; Player Settings &gt; (Select WebGL icon) &gt; Publishing Settings &gt; Compression Format</code>.</p>
<h3 id="the-deploy-script"><a class="header" href="#the-deploy-script">The deploy script</a></h3>
<p>The deploy script cannot be executed before (or in parallel with) the build script, as it requires an uploaded build to generate its deployment. To make sure or this order we tag the deploy script with <code>needs: build</code>, then we give it a name and set it to run in linux:</p>
<pre><code class="language-yaml">  deployPages:
    needs: build
    name: Deploy to Github Pages 🚀
    runs-on: ubuntu-latest
    steps: …
</code></pre>
<p>Now the necessary steps are to download the artifact from the storage and run an action to deploy it in github pages, we can do that with the following actions:</p>
<pre><code class="language-yaml">deployPages:
    …
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - uses: actions/download-artifact@v2
        with:
          name: build-WebGL
          path: build

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@4.1.4
        with:
          branch: gh-pages
          folder: build/WebGL
</code></pre>
<p>Now, check the github pages and play. The link to your github pages can be found in your repository at <code>Settings &gt; Pages</code>.</p>
<p>One important notice is that to deploy to Android and iOS some packaging conventions may be required, for Android the package must be named <code>com.YourCompanyName.YourProductName</code>. More information on deploying to platforms may be found at game ci.</p>
<h1 id="chapter-8-introduction-to-game-testing-with-game-engines-and-setting-up-a-test-environment"><a class="header" href="#chapter-8-introduction-to-game-testing-with-game-engines-and-setting-up-a-test-environment">Chapter 8: Introduction to game testing with game engines and setting up a test environment.</a></h1>
<p>For game development frameworks like Monogame, GGEZ, Raylib, Pygame, LibGDX, Phaser that behave like packages (libraries, crates, or, however, you call it), it is  fairly easy to develop games and have a good test coverage on them. Sadly, most games developed with these frameworks are poorly tested or have no test at all. Besides famous game development frameworks there are a few game engines that allow us some level of testing, especially when we use the language native testing resources, like Panda3D, Godot, Amethyst, AppGameKit and jMonkey. However, when we speak about the big engines in the market like Unity, Unreal and CryEngine the reality is not that simple. Fortunately, Unity has been putting great effort into making games testable.</p>
<p>I first heard of automated testing in Unity a few years back when they released the package called <a href="https://github.com/spe3d/unitytesttools">Unity Test Tools</a>. This package was deprecated and later included in the current <code>Unity Test Runner</code>, which is now incorporated into the engine. Test runners are basically a test executor and in the case of Unity a test executor that can run specific Unity tests. Also, around the same time I saw a few talks from Tomek Paszek and in one of them he expressed that one of the motivations behind the Unity Test Tools package was the fact that some parts of unity were being developed with unit testing, but there was no testing resource for the games themselves.</p>
<p>Currently it is fairly easy to find resources about testing and game development, and there is even an article written by Sophia Clarke called <a href="https://blog.unity.com/technology/testing-test-driven-development-with-the-unity-test-runner">Testing Test Driven Development with Unity</a> where she explores the viability of developing a game with TDD in Unity. Also, I highly recommend reading the <a href="https://docs.nunit.org/">NUnit C# test package documentation</a>, as it is the default test package for Unity.</p>
<p>Now we can start the test environment setup and run some simple tests. </p>
<h2 id="configuring-the-unity-test-environment"><a class="header" href="#configuring-the-unity-test-environment">Configuring the Unity test environment</a></h2>
<p>The first thing we need to do is download the latest Unity version, this book was written using <strong>Unity 2020.3.16f1 LTS</strong>, so the test setup is supposed to be usable in a few later versions, as well as versions 2018 and 2019. With the Unity Hub downloaded, login and activate your license. Then choose version 2020.3.16f1 LTS and download it.</p>
<p>Unity has two type annotations, <code>[Test]</code> and <code>[UnityTest]</code>. The difference between them is that <code>UnityTest</code> can execute in <code>playmode</code> and make assertions over actions and events in playmode, while <code>Test</code> executes only over functions that are independent from the playmode, namely editmode. The following step by step may seem trivial, but as it can be little altered from version to version, it is important to have it written down so at least for the 2020 LTS version, anyone can do it.</p>
<ol>
<li>Download UnityHub from https://store.unity.com/pt/download.</li>
<li>Login and activate your license in preferences.</li>
<li>Download Unity version 2020.3.16f1 LTS.</li>
<li>Click in <strong>NEW</strong> to create a new project.</li>
<li>Choose the 3D template and a project name. My project name was <em>FPSwithTDD</em>.</li>
<li>To find the test runner go to <code>WINDOW &gt; GENERAL &gt; TEST RUNNER</code>.</li>
</ol>
<p><img src="part-1/../Images/unity-test-runner.png" alt="Unity Test Runner" />
Image: Unity test runner</p>
<ol start="7">
<li>At first, the Test Runner should be empty as no test has been configured. To create a <code>Test Assembly Folder</code> you should click in <code>Create EditMode Test Assembly Folder</code> and then a folder <code>Tests</code> will be created.</li>
<li>If we open the <code>Test Assembly File</code> inside the <code>Tests</code> folder we will see a bunch of pre-selected configurations. Be sure to check the desired test platforms in the <code>platforms</code> field.</li>
<li>Now we need to create a demo test, to do that click on <code>Create Test Script in current folder</code>. I named my new test script <code>DemoTestScript</code>. If we open the test script we will see that the two testing frameworks are being used using <code>NUnit.Framework</code> for using <code>[Test]</code> and <code>Assert</code> as well as using <code>UnityEngine.TestTools</code> for using <code>[UnityTest]</code>. <code>UnityTest</code> should have a return type of <code>IEnumarator</code> and you can use <code>yield return null</code> to skip 1 frame.</li>
</ol>
<pre><code class="language-c#">using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
 
public class DemoTestScript
{
   // A Test behaves as an ordinary method
   [Test]
   public void DemoTestScriptSimplePasses()
   {
       // Use the Assert class to test conditions
   }
 
   // A UnityTest behaves like a coroutine in Play Mode. In Edit Mode you can use
   // `yield return null;` to skip a frame.
   [UnityTest]
   public IEnumerator DemoTestScriptWithEnumeratorPasses()
   {
       // Use the Assert class to test conditions.
       // Use yield to skip a frame.
       yield return null;
   }
}
</code></pre>
<ol start="10">
<li>To run the tests go to the Test Runner and click <code>Run All</code>.</li>
</ol>
<p><img src="part-1/../Images/exec-test.png" alt="Executing all tests" />
Image: Executing all tests</p>
<ol start="11">
<li>There is another annotation that may be interesting to know. <code>[UnityPlatform]</code> helps us determine the target (or excluded) platform to execute the tests. To define a target platform, let's say Windows, define it as <code>[UnityPlatform(RuntimePlatform.WindowsEditor)]</code>. To exclude Windows platform we can just use <code>[UnityPlatform(exclude = new[] {RuntimePlatform.WindowsEditor })]</code>.</li>
<li>Finally, it is important to know that if you want to test logs you can use the Unity assertion for logs as follows: <code>LogAssert.Expect(LogType.Log, &quot;Log message&quot;)</code>.</li>
</ol>
<h2 id="writing-our-first-test"><a class="header" href="#writing-our-first-test">Writing our first test</a></h2>
<p>The first test we will write is a check to know if our player is alive. To do that  we need to create a new test script, which I will call <code>PlayerAliveTestScript</code>, go to the Tests folder and click in <code>Create &gt; Testing &gt; C# Test Script</code> and rename it. I have created only one <code>[Test]</code> defined by <code>public void IsAlive_WhenInstantiated_ReturnsTrue()</code>.</p>
<p>Now we need to create a Scripts folder and in it I have created a script called <code>PlayerLife</code>. This script will have a function called <code>IsAlive</code> that will return a <code>bool</code>. And now our test <code>IsAlive_WhenInstantiated_ReturnsTrue</code> will be testing if the function call <code>IsAlive</code> on the variable <code>player</code> of type <code>PlayerLife</code> is true. The test will look like this:</p>
<pre><code class="language-C#">[Test]
public void IsAlive_WhenInstantiated_ReturnsTrue()
{
   var player = new PlayerLife();
   Assert.AreEqual(true, player.IsAlive());
}
</code></pre>
<p>So, we need to make this test compile creating the function <code>IsAvile</code> in <code>PlayerLife</code> script. Be aware that if your script inherits from <code>MonoBehaviour</code> you should not use the <code>new PlayerLife()</code> declaration, it works with the warning <code>&quot;You are trying to create a MonoBehaviour using the 'new' keyword.  This is not allowed.</code>  MonoBehaviours can only be added using <code>AddComponent()</code>. Alternatively, your script can inherit from ScriptableObject or no base class at all&quot;.</p>
<pre><code class="language-C#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
 
public class PlayerLife : MonoBehaviour
{
   public bool IsAlive() {
       return false;
   }
}
</code></pre>
<p>However, if we try to execute the test runner we will get a message saying <code>&quot;Assets/Tests/PlayerAliveTestScript.cs(12,26): error CS0246: The type or namespace name 'PlayerLife' could not be found (are you missing a using directive or an assembly reference?)&quot;</code>. This compilation error is telling us that to associate the scripts with the tests we need an <code>assembly reference</code>. To solve this problem, we need to right click in <code>Scripts</code> folder and select <code>Create &gt; Assembly Definition</code>. I named my scripts assembly definition as <code>ScriptsDefinition</code>. With this done, we can go to the Tests folder assembly definition and create a new <code>Assembly Definition Reference</code> by clicking the <code>+</code> button. And then drag and drop the assembly definition from the scripts folder into the <code>Missing Reference</code> new field.</p>
<p><img src="part-1/../Images/new-assembly.png" alt="Creating a new Assembly Definition Reference" />
Image: Creating a new Assembly Definition Reference</p>
<p>To make this test pass we can, for now, make it return true and have the test pass. The last step is to fix the warning <code>&quot;You are trying to create a MonoBehaviour using the 'new' keyword...&quot;</code>. To do that we will need to define a <code>SetUp</code> annotation that creates a <code>GameObject</code> and adds the component <code>PlayerLife</code> to it. Now, instead of declaring a <code>new PlayerLife()</code> every time we need to access the MonoBehaviour, we can use <code>GetComponent&lt;PlayerLife&gt;()</code>. As follows:</p>
<pre><code class="language-C#">using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
 
public class PlayerAliveTestScript
{
   GameObject go;
 
   [SetUp]
   public void SetUp() {
       go = new GameObject(&quot;test&quot;);
       go.AddComponent&lt;PlayerLife&gt;();
    }
 
   [Test]
   public void IsAlive_WhenInstantiated_ReturnsTrue()
   {
       PlayerLife player = go.GetComponent&lt;PlayerLife&gt;();
 
       Assert.AreEqual(true,player.IsAlive());
   }
}
</code></pre>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>To remember important actions on configuring test environments in Unity I will sum them up here:</p>
<ol>
<li>You can find the test runner at <code>WINDOW &gt; GENERAL &gt; TEST RUNNER</code>.</li>
<li>In the test runner click in<code> Create EditMode Test Assembly Folder</code> and then a folder Tests will be created.</li>
<li>In the Assembly Definition of the tests folder, check all required platforms.</li>
<li>To create a new test script just click the button with the message <code>Create Test Script in current folder</code>.</li>
<li>To execute the available test scripts just click <code>Run All</code> in the top left corner of the test runner.</li>
<li>To create new tests you can just go to <code>Create &gt; Testing &gt; C# Test Script</code>.</li>
<li>To use scripts outside the <code>Tests</code> folder you should define a Scripts folder and add an Assembly Definition to it, <code>Create &gt; Assembly Definition</code>. The Tests folder should have an Assembly Definition Reference to the Scripts folder Assembly Definition.</li>
<li>Now you can use other scripts and tests them.</li>
</ol>
<h1 id="chapter-9-best-practices-writing-tests"><a class="header" href="#chapter-9-best-practices-writing-tests">Chapter 9: Best Practices Writing Tests</a></h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices">C# best practices for unit testing</a></p>
<p>There are a few types of tests and best practices may vary depending on which test you are writing and how they are organized. One thing I like a lot is to separate integration and unit tests, usually doing it by putting in different folders. For Unity, you could separate unit tests from integration tests by creating two different folders with two different assembly definitions, like <code>UnitTests</code> and <code>IntegrationTests</code>, something like <code>UnitTests</code> and <code>PlayTests</code>.</p>
<p>Also, even in Unity, I like to avoid slow unit tests. To do so, I leave tests that will be slower, even if they are unitary, to run separately from the fast unit tests. Another thing is that I avoid too many dependencies in unit tests and if I have them, I tend to pass them as arguments, especially those that have side-effects. Speaking of side-effects, I usually try to avoid unit testing functions that have side-effects, so I usually write my functions as pure as possible, not like <code>PlayerLife.IsAlive</code>, which is mostly a getter.</p>
<p>Having said that we can point out a few important characteristics of a good unit test:</p>
<ul>
<li>Fast: good projects may have thousands or tens of thousands of unit tests, so they should execute quickly so that they can be executed more frequently.</li>
<li>Isolated: they should be standalone and so be executed in isolation from other contexts, dependencies or external systems.</li>
<li>Repeatable: They should be like pure functions, so for every time you run them, the same result should be expected. This, also, allows them to be executed frequently.</li>
<li>Self-checking: this might seem dumb for people that are used to automated testing, but many game developers are not used to this concept. A test should be capable of detecting its success or failure without any human interaction.</li>
<li>Quick execution: if a test takes too long to write or too long to execute, consider designing better tests or consider designing a code that is more testable.</li>
</ul>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p>C# has a good set of best practices and naming conventions for writing code and writing test, so when we are writing a new test we should consider the following three parts:</p>
<ol>
<li>The name of the method being tested. (<code>IsALive</code>)</li>
<li>The scenario under which it is being tested. (<code>WhenInstantiate</code>)</li>
<li>The expected behaviour of this scenario. (<code>ReturnsTrue</code>)</li>
</ol>
<p>Additionally we could declare the specific component that we are testing <code>PlayerLife_IsAlive_WhenInstantiated_ReturnsTrue</code>. Also, naming conventions are important because they explicitly express the intent of the test. This explicit expression is not just about readability as it serves as documentation for when someone is reading a test file to understand exactly what are the expected behaviours of a class, namespace, component or object.</p>
<p>Another topic that frequently causes confusion is the words <strong>Fake</strong>, <strong>Mock</strong> and <strong>Stub</strong>:</p>
<ul>
<li>Fake - fake is the generic term used to describe an object that is not real or doesn't behave as a real object. A fake can be a stub or a mock, it all depends on the context.</li>
<li>Mock - A mock is a fake object that influences the behaviour of the test depending how it is described. So, in other words, a mock starts a fake until asserted against.</li>
<li>Stub - A stub is a dependency or a collaborator system that controls how it is going to be used in regards to replacing a part of our test. The general advantage of a stub is that you can execute the test without having to deal directly with a dependency.</li>
</ul>
<p>The last thing I want to talk about before starting our game is how to write the tests themselves and the two main things that come to my mind is to keep your tests minimal and follow some kind of pattern like <strong>Arrange, Act and Assert</strong>. </p>
<p>On the topic of keeping our tests minimal, it means that the input passed to the function being tested should always be kept the simplest possible, for example, Rust linting tool, clippy, warns you if your function has too many arguments. Another thing that is important to say about simple inputs is that they should be predictable, so we can achieve the same result for every test execution. What do we achieve with this principle? Tests become more resilient to future implementations and the test behaviour is closer to the expected functionality. </p>
<p>Lastly, on the Arrange, Act, Assert topic, it is a common pattern when writing tests and, as the name implies, it breaks down into three sets of actions:</p>
<ul>
<li>Arrange - create necessary objects and set them to the correct state.</li>
<li>Act - define the action that will be tested.</li>
<li>Assert - asserts that the act action has the expected value.</li>
</ul>
<p>Now we have a clear idea of what TDD is and how to use it, we have configured our Unity test environment and we are clear on the test practices that we are going to use in this book. I would say we are ready to starting writing some great tests for our first person shooter. </p>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>In this book section we learned that:</p>
<ol>
<li>TDD is a continuous cycle of test, code and refactor that will always generate well tested code, a code that is probably simpler, as well as quickly identify bugs that would break other tests.</li>
<li>We learned some TDD practices, like keeping your tests simple and independent from one another.</li>
<li>Why there is so much poorly tested code, considering some of the history and biases that the game industry had.</li>
<li>Why TDD is important for game development, which discusses the fact that games have an art/entertainment relation as well as the hardships of testing game UI and Gameplay.</li>
<li>When to use TDD and the way to think about basic walk, jump and fall mechanics on the TDD side of things.</li>
<li>How and why to use CI for game development and associate TDD with it.</li>
<li>Important aspects of configuring a test environment on Unity like the test runner location and the necessary assemble definitions and references.</li>
<li>Lastly, some best practices writing tests.</li>
</ol>
<h1 id="tdding-a-fps-game-in-unity"><a class="header" href="#tdding-a-fps-game-in-unity">TDDing a FPS Game in Unity</a></h1>
<h1 id="chapter-10-developing-a-fps-game-with-tdd"><a class="header" href="#chapter-10-developing-a-fps-game-with-tdd">Chapter 10: Developing a FPS game with TDD</a></h1>
<p>Let us start by defining what is a FPS game. FPS means First Person Shooter and it is that kind of game where you only see a weapon and sometimes a HUD, it is first person because you play as if you were looking with your own eyes into that world. Another common type of game is third person, which allows you to see your playable character's body. Also, a FPS is a shooter game, which means that we will have some kind of weapon that shoots projectiles at something else.</p>
<h4 id="game-design-document"><a class="header" href="#game-design-document">Game Design Document</a></h4>
<p>The Agile Manifesto tells us that we should aim for &quot;<strong>Working software</strong> over comprehensive documentation&quot;, which I totally agree with, but on the other hand, having some documentation is also important to have a clear view of what our tests should do and how they should behave. I also agree that &quot;<strong>Responding to change</strong> over following a plan&quot; is clearly important for game development which means that this Game Design Document will only serve as an initial reference to what the game will look like so I don't really expect that the game will be just like the GDD, but I expect that the GDD will provide me with enough material and ideias to start planning ahead basic tests scenarios, scenes and implementations. As this will be a very simple GDD and a very simple game, I don't expect much conflict between them, but if it happens don't worry, it is how things happen in real life.</p>
<h2 id="the-story"><a class="header" href="#the-story">The Story</a></h2>
<p>TBD</p>
<!-- The game is very simple, our player spawn inside a bathroom where they should interact with a door, opening it, to see one enemy washing their face, so we shoot and kill them. After that, our player will move into a larger room, by interacting with another door and see that two more enemies are aiming at them, so our player shoots and kills to advance into the next room. Beware! The next room has some errand enemies walking and they will follow us and when near enough, shoot at us. We may need to hide in corners so that we can shoot without being seen. There will be 3 rooms to explore, 1 of them has a secret and the others are packed with enemies, what will we do to get to our secret? -->
<h2 id="the-character-controller"><a class="header" href="#the-character-controller">The Character Controller</a></h2>
<p>Our character movement will be pretty simple. It will go forward by clicking <code>w</code> or <code>up</code> and back by clicking <code>s</code> or <code>down</code>. Also we can move sideways by clicking <code>a,d, left, right</code>. Last character controller feature that I want to introduce is something that I really like from games like Rainbow Six which is bend left and bend right, which will be q and e, respectively. Bending means that our character will look to rotate a little to the side with its origin being the character bottom. By pressing the space bar the character will jump and gravity will act on it.</p>
<h2 id="the-camera"><a class="header" href="#the-camera">The Camera</a></h2>
<p>Like all FPS that I know, the camera will follow the character in a first person perspective and the character will look in the direction that the mouse is pointing. If you move when the mouse is pointing some sideways the character will move in that direction. </p>
<h2 id="weapons"><a class="header" href="#weapons">Weapons</a></h2>
<p>TDB</p>
<!-- There will be 2 weapons, which we can switch between by clicking the number `1` (rifle) and `2` (pistol), and shoot by clicking the left mouse button. Also by scrolling the mouse scroller or by keeping shift pressed you can scope the weapon. If you scope the rifle your shooting mode will change to single rounds and when not scoped you will have an automatic rifle. Pistol rounds are always single rounds. Reloading can be done by pressing `r`. Lastly, we will have grenades that can be thrown by pressing `f`. -->
<h2 id="the-enemies"><a class="header" href="#the-enemies">The Enemies</a></h2>
<p>TDB</p>
<!-- There will be 2 types of enemies. The first type spawns at specific, mostly, closed positions and don't move, they are like campers looking at x/y positions or doing some business of their own (like washing their hands). The second type spawns in open spaces and can walk around the base. The second type also moves around between predetermined points and if the character gets near their site, they follow the character until they can shoot. -->
<h2 id="life-systems"><a class="header" href="#life-systems">Life Systems</a></h2>
<p>TDB</p>
<!-- The life system is pretty simple, enemies have a life health bar over their head with life 100% and the player has its life in the bottom left part of the HUD. Rifle shots take 24% of a character's life, pistol shots take 18% of a character's life, grenades take 120% decreasing with range and headshots take 100% of a character's life.  -->
<h2 id="how-to-deliver"><a class="header" href="#how-to-deliver">How to Deliver</a></h2>
<p>Delivering in this project will be done in github CI with the following steps:</p>
<ol>
<li>Test</li>
<li>Build</li>
<li>Deliver artifact to WebGL platform</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
